Міністерство освіти і науки України Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук Кафедра програмної інженерії
КУРСОВА РОБОТА ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення» Тема роботи: Навчальна програмна система для тестування знань студентів

Студент гр. ПЗПІ-21-6	 	Розов А.О.
(підпис)
 
Керівник роботи
 


(підпис)
Роботу захищено «
 
ст. викл. Сокорчук І.П.

»	2024 р.
 
 
з оцінкою  	


Комісія:	 	доц. Лещинський В.О.
(підпис)
 	доц. Лещинська І.О.
(підпис)
 	ст.викл. Сокорчук І.П.
(підпис)




Харків 2024 р.
 
Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук	Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення	
Курс	3	Семестр	6		 Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ


 	Розову Артему Олексійовичу	
1.	Тема	роботи:	«Навчальна	програмна	система	для	стеження за транспортними засобами підприємств»					
2.	Термін узгодження завдання курсової роботи « 01»     березня	2024 р.
3.	Термін здачі студентом закінченої роботи « 06»     червня	2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити: додавання нового студента, тестів, редагування тестів, ведення журналу. Використовувати ОС Windows 10, СКБД Microsoft SQL Server 2019, середовище розробки Microsoft Visual Studio 2019	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити) вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки	
 
КАЛЕНДАРНИЙ ПЛАН


№	Основні етапи виконання проєкту
в рамках лабораторних робіт	Термін виконання
етапів	Примітка
1	Vision & Scope	21.03.2024	
2	Back-end частина програмної системи	04.04.2024	
3	Програмне забезпечення для  IoT або SmartDevice пристрою	25.04.2024	
4	Front-end частина програмної системи	16.05.2024	
5	Мобільний програмний  застосунок	06.06.2024	

Дата видачі теми проєкту «    01	»        березня	2024 р.


Викладач лабораторних робіт                                           ст. викл. Сокорчук І.П.
           (підпис)


Завдання прийняв до виконання
ст.гр. ПЗПІ-21-6	 		Розов А.О. 
(підпис)
 
РЕФЕРАТ


	Пояснювальна записка до курсового проектування: 39 с., 6 рис., 1 табл., 6 джерел, 5 додатків.
АРХІТЕКТУРА ПРОГРАМИ, ІНТЕРНЕТ РЕЧЕЙ, КЛІЄНТ, МОВА ПРОГРАМУВАННЯ С#, МОВА ПРОГРАМУВАННЯ JAVA, ОБ’ЄКТНО-ОРІЄНТОВАНЕ ПРОГРАМУВАННЯ, ANDROID STUDIO, ESP32, MVC, MVP, VISUAL STUDIO
Мета роботи - це розробка програмної системи для боротьби з втратами товару та занадто довгими за часом перевезеннями. Розробка системи, що надає точні вимірювання та віддалене управління, забезпечуючи максимальну продуктивність. Система, що дозволяє перевіряти завантаження товаром та вивантаження. Отже, основні напрями розвитку продукту  - це зручний віддалений моніторинг. 
Поставлена задача вирішується шляхом проектування та кодування програмного продукту за обраною предметною областю. Під час розробки використовуються різні технології та засоби розробки, такі як .NET, ASP.NET, SQL Server для серверної частини, Java Script, HTML та css для клієнтської частини, C++ для розумних пристроїв, Java для мобільного додатку.
Результатом роботи стала система, що дозволяє відстежувати транспортні засоби та маршрути, та полегшувати моніторинг вантажу, працівників та транспортних засобів для власників підприємств.


ЗМІСТ


ВСТУП                                                                                                                       7
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ                                                                      8
	1.1 Загальний огляд                                                                                         8
1.3	Аналіз існуючих аналогів                                                                          8
	1.3 Потреби потенційних користувачів                                                        9
2	ПОСТАНОВКА ЗАВДАННЯ                                                                              10
2.1	 Бачення програмної системи                                                                    10
2.2	 Основні функції системи                                                                         10
2.3 Обсяг початкового випуску                                                                    10   
2.4 Обсяг наступних випусків                                                                      12   
2.5 Обмеження та винятки                                                                             12   
2.6 Робоче середовище                                                                                 13    
3 АРХІТЕКТУРА ТА ПРОЄКТУВАННЯ СИСТЕМИ                                       14
3.1 Опис загальної архітектури системи                                                    14 
3.2 Архітектура серверної частини                                                              15
3.3 Архітектура клієнтської частин                                                            16
3.4 Архітектура програмного забезпечення для розумних пристроїв     18
3.5 Архітектура мобільного застосунку                                                      19
3.6 Структура бази даних                                                                             20
4 РЕАЛІЗАЦІЯ ПРОГРАМНОЇ СИСТЕМИ                                                         23
4.1	Реалізація серверної частини                                                           23
ВИСНОВКИ                                                                                                           26
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ                                                                     27
ДОДАТОК А                                                                                                          28
ДОДАТОК Б                                                                                                          31
ДОДАТОК В                                                                                                          34
ДОДАТОК Г                                                                                                            36
ДОДАТОК Д                                                                                                           39


ВСТУП


	На зараз існує дуже багато компаній перевізників вантажу. Для багатьох власників одним з важливих критеріїв є довіра до водіїв вантажу та можливість перевірити де в який момент знаходяться вантаж та автомобіль, що доставляє цей вантаж, перевірити де автомобіль розвантажувався та яким шляхом їхав до кінцевої точки. 
	Розробка програмної системи для відстеження транспортних засобів підприємств спрямована саме на вирішення цих проблем. Система інтегрує датчики GPS для відстеження автомобілів в режимі реального часу. Відповідно власники бізнесу можуть завжди перевіряти своїх водіїв.
	Метою даної роботи є створення системи для власників підприємств, щоб ті могли перевіряти свій вантаж та водіїв. Система повинна складатися з декількох взаємопов’язаних між собою компонентів (серверна частина, клієнтська частина, розумні пристрої та застосунок для мобільних девайсів). Під час розробки необхідно дотримуватися принципів побудови масштабованої архітектури. 
Для поставленої задачі необхідно проаналізувати предметну область і потреби потенційних користувачів, розробити архітектуру програмної системи та її окремих компонентів, програмно реалізувати та протестувати усі частини системи.


1	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	 Загальний огляд


У сучасному світі, ефективне управління транспортними засобами підприємств відіграє важливу роль у забезпеченні ефективності бізнесу. Відстеження руху, облік використання ресурсів, планування маршрутів і підтримання відповідності правилам безпеки та регуляторним вимогам - це лише деякі з важливих аспектів, які необхідно враховувати при розробці програмної системи для цієї галузі.


1.2	 Аналіз існуючих аналогів


Ринкова можливість для цього продукту полягає в постійному попиті на ефективні рішення для стеження за транспортними засобами. Серед вже існуючих аналогів можна виділити «Tocan» та ще безліч програмних систем, які надають GPS моніторинг транспортних засобів, але у даних аналогів є наступні мінуси: вартість (вартість покупки, встановлення та налаштування даних систем може бути дуже великою), комплексність (не всім користувачам потрібна система за якою вони не зможуть слідкувати самостійно та будуть потребувати в технічній підтримці), всі аналоги дозволяють лише GPS моніторинг транспортних засобів та на цьому їх функціонал завершується, тому дану ідею можна розвивати та покращувати.  Відповідно, можна зробити висновок, що рішення, яке б включало в себе функціонал більший за звичайний GPS моніторинг на разі не існує.


1.3	 Потреби потенційних користувачів


Основними клієнтами системи є власники підприємств або адміністратори цих самих підприємств, що займаються перевезеннями. 
Основні потреби користувачів:
•	Точний та надійний моніторинг транспортних засобів та перевезень товару.
•	Можливість віддаленого моніторингу через мобільні пристрої та веб-інтерфейси.
•	Перегляд статистики щодо транспортних засобів та водіїв, про їх працю.


2	ПОСТАНОВКА ЗАВДАННЯ
2.1	 Бачення програмної системи


Головна мета програмної системи - це боротьба з втратами товару та занадто довгими за часом перевезеннями. Система надає точні вимірювання та віддалене управління, забезпечуючи максимальну продуктивність. Продукт дозволяє перевіряти завантаження товаром та вивантаження. Отже, основні напрями розвитку продукту  - це зручний віддалений моніторинг. В результаті використання продукту, клієнт стане більше довіряти своїм працівникам та зможе завжди перевірити де товар та транспортні засоби.


2.2	 Основні функції системи


Основна функціональність продукту включає:
•	Точний моніторинг транспортних засобів: Забезпечення високої точності їх місцезнаходження у реальному часі.
•	Точний моніторинг товару: Можливість віддаленого моніторингу коли товар завантажують у транспортний засіб або вивантажують через веб-інтерфейси та мобільні додатки.
•	Сповіщення: сповіщення про завантаження та вивантаження товару та про те, що транспортний засіб виконав певну дію.
•	Дані та аналітика: Збір даних та можливість створювати звіти для прийняття управлінських рішень.


2.3	 Обсяг початкового випуску


Перша версія продукту фокусується на найважливіших функціях та можливостях, які нададуть найбільшу цінність різним групам користувачів. Спрямована насамперед на досягнення бізнес-цілей, перша версія включає:
1	Точний GPS моніторинг транспортних засобів: забезпечує надійність та високу точність вимірювань GPS у реальному часі.
2	Віддалене управління: можливість віддаленого моніторингу всіх транспортних засобів підприємства через веб-інтерфейси та мобільні додатки.
3	Сповіщення: автоматичне сповіщення про не звичну поведінку транспортного засоба.
4	Дані та аналітика: збір даних та звітність для прийняття управлінських рішень.
5	Можливість прогнозування майбутніх витрат на кожному транспортому засобів (на пальне).
Комп’ютерна версія застосунку буде мати наступні можливості:
1	Перегляд даних та результатів аналізу даних.
2	Можливість моніторингу транспортних засобів у режимі реального часу.
3	Можливість включення\вимкнення системи GPS.
4	Можливість адміністрування доступом з інших девайсів.
5	Можливість перемикання мови (українська\англійська).
Мобільна версія застосунку буде мати наступні можливості:
1	Можливість налаштування роботи системи.
2	Можливість включення\вимкнення системи GPS.
3	Отримання сповіщень про незвичні ситуації.
4	Можливість перемикання мови (українська\англійська).
Серверна версія застосунку буде мати наступні можливості:
1	Зберігання даних.
2	Аналіз даних.
3	Захист персональних даних.
4	Прогнозування даних на основі попередніх результатів.
Застосунок повинен стати повноцінним продуктом після втілення всіх перерахованих вище функцій та мати можливість надавати повний функціонал користувачам.


2.4 Обсяг наступних випусків


Планується поетапний розвиток продукту з випуском наступних версій, які включатимуть:
•	Розширений функціонал моніторингу: додаткові можливості для відстеження транспортних засобів.
•	Підтримка нових протоколів та інтерфейсів: можливість інтеграції з іншими системами.
•	Збільшена аналітика та звітність: Розширена функціональність для аналізу даних та прийняття більш інформованих рішень.


2.5	 Обмеження та винятки


Деякі функції та характеристики, які можуть очікувати зацікавлені сторони, не будуть включені в перший продукт:
•	Спеціалізовані апаратні засоби: Підтримка конкретних апаратних засобів може бути відкладена до майбутніх випусків.
•	Загальні рішення для всіх галузей: Перший випуск фокусується на індустрійних застосуваннях та може не включати загальні рішення для галузей, де деталізований контроль не потрібен.
•	Великі обсяги даних: Перший випуск може не мати великої масштабованості для дуже великих обсягів даних.
Ці обмеження та виключення обґрунтовані потребами ринку та допомагають забезпечити реалістичні очікування для всіх сторін, а також фрейм для подальших рішень про зміни вимог та функціональності.


2.6	 Робоче середовище


Для серверної розробки буде використано ASP.NET та субд таку як MS SQL Server. Для розробки серверної частини буде використано мову програмування C# в середовищі розробки Visual Studio.
Для front-end розробки буде використано мови як java script, HTML та css для дизайну. Середовище розробки для цього – це Visual Studio.
Для мобільної версії додатку буде використано мову програмування java в наступному середовищі розробки - Android Studio.
Для розробки iot частини програми потрібен датчик GPS та датчик ваги. Для програмування даного датчика потрібно середовище розробки Arduino IDE та така мова програмування як C++.


3 АРХІТЕКТУРА ТА ПРОЄКТУВАННЯ СИСТЕМИ
3.1 Опис загальної архітектури системи


Програмна система складається з кількох основних компонентів, які взаємодіють між собою для забезпечення відстеження транспортних засобів підприємств.
	Представлення взаємодії усіх компонентів, з яких складається система, наведено на діаграмі розгортання (рисунок 3.1).
 

Рисунок 3.1 – Діаграма розгортання

Пояснення до діаграми розгортання. Мобільний застосунок, веб-застосунок та iot-девайс взаємодіють з центральним сервером для обміну інформацією. Передачу даних реалізовано за допомогою HTTPS протоколу. Центральний сервер взаємодіє з базою даних для зберігання та отримання інформації. Iot-девайс відправляє дані про рух транспортних засобів до серверу, який потім зберігає ці дані в базі даних. Користувачі можуть використовувати мобільний застосунок та веб-застосунок для доступу до інформації.


3.2	Архітектура серверної частини


Для серверної частини було використано MVC. 
Модель відповідає за управління даними додатку. Це включає класи, які представляють сутності системи, такі як транспортні засоби, їх рух, користувачі тощо. 
Контролер відповідає за обробку вхідних запитів та відправку відповідей. Це буде клас або набір класів, які містять методи для обробки HTTP-запитів, таких як GET, POST, PUT, DELETE. Контролери в ASP.NET MVC можуть повертати дані в форматі JSON або XML, в програмній системі для відстеження транспортних засобів підприємств дані повертаються у форматі JSON.
	Представлення були розроблені для веб-застосунку, тому їх опис буде відповідно з архітектурою веб-застосунку.
	Також, для серверної частини присутня діаграма прецедентів, яку відображено на рисунку 3.2.
	Пояснення до діаграми прецедентів. Кожен користувач може переглядати всі свої перевезення, в яких відображено за яким маршрутом та яким водієм воно виконується або виконувалося. Також є можливість перегляду місцезнаходження автомобілів за допомогою датчику GPS встановленому в кожне авто підприємства.

 
Рисунок 3.2 – Діаграма прецедентів


	3.3	Архітектура клієнтської частин


	Клієнтську частину було розроблено за допомогою JavaScript, HTML та css. Було створено представлення, які визиваються за допомогою контролерів у серверній частині. За доступ користувачів до певних endpoints відповідає модуль маршрутизації (Router module). Він визначає, які модулі та компоненти треба завантажувати при запиті певної кінцевої точки користувачем.
	Діаграму компонент для клієнтської частини відображено на рисунку 3.3
 
Рисунок 3.3 – Діаграма компонент

Пояснення до діаграми компонент: 
•	Користувацький інтерфейс: взаємодіє з користувачами системи, отримує дані від сервера.
•	Сервер: керує взаємодією між клієнтом та сервером, отримує запити від користувацького інтерфейсу та передає їх до відповідних компонент. 
•	Сервіс аутентифікації: обробляє запити на аутентифікацію та авторизацію. Пов’язан з сервером для перевірки користувачів.
•	GPS датчик: збирає дані о місцезнаходженні транспортних засобів, відправляє дані до модуля обробки даних.
•	Модуль обробки даних: обробляє дані о місцезнаходженні отримані від датчика GPS. Взаємодіє з базою даних для зберігання оброблених даних.
•	База даних: зберігає дані. Взаємодіє з іншими компонентами за для передачі даних.
•	Сервіс повідомлень: відправляє повідомлення користувачам.


	3.4	Архітектура програмного забезпечення для розумних пристроїв


	У системі наявний один пристрій – GPS датчик, за допомогою якого можна відстежувати транспортні засоби та вантаж. Також за допомогою цього можна малювати маршрут, яким рухався водій. Для реалізації функціоналу розумних пристроїв використовується мікроконтролер ESP32. За допомогою підключення до Wi-Fi та можливості відправки HTTP запитів на сервер, розумний пристрій може оновлювати інформацію про місцезнаходження транспортного засобу.
	Діаграму пакетів для розумного пристрою відображено на рисунку 3.4
 
Рисунок 3.4 – Діаграма пакетів
	Пояснення до діаграми пакетів: 
•	UI (користувацький інтерфейс): пакет, що відповідає за користувацькі інтерфейси. Взаємодіє з сервером для виконання операцій.
•	Сервер: зберігає основні сервіси та системи. Взаємодіє з даними для доступу до них та з інтегрованими системами для отримання даних від них.
•	Дані: відповідає за зберігання даних. Взаємодіє з сервером для представлення та зберігання даних.
•	Інтеграція: пакет, що відповідає за інтеграцію зовнішніх пристроїв. Взаємодіє з сервером для передачі даних в систему.


3.5	Архітектура мобільного застосунку


Андроід застосунок було створено за допомогою мови програмування Java та середи розробки Android Studio. Для підключення серверної частини було використано бібліотеку Retrofit. Було використано MVP архітектуру. Модель в MVP відповідає за управління даними додатку. Представлення відображає інтерфейс користувача додатку. Це XML-файл для макету в Android Studio, який визначає, як виглядатиме сторінка. Presenter в MVP є прослойкою між моделлю та видом. Відповідає за обробку бізнес-логіки, отримання даних з моделі та підготовку їх для відображення в виді.
Для андроід застосунку наведено діаграму станів. Її можна побачити на рисунку 3.5

 
Рисунок 3.5 – Діаграма станів

Пояснення до діаграми станів. 
	Початок позначений точкою та надписом «Старт». Користувачі потрапляють до вікна «Вхід в акаунт». Якщо логін або пароль введено неправильно – нічого не відбудеться. Якщо натиснути кнопку «Реєстрація» - потрапите до реєстрації нового акаунту. Якщо ввести логін і пароль правильні – то потрапите до перегляду всіх перевезень даного клієнта (так само і при успішній реєстрації).
	З вікна «Перегляд всіх перевезень» можна потрапити на додавання нового перевезення або до мапи з усіма транспортними засобами.


3.6	Структура бази даних


Схему баз даних відображено на рисунку 3.6.

Рисунок 3.6 – Схема бази даних

Таблиця Routes має в собі інформацію про маршрути переміщення транспортних засобів. Стартову точку, кінцеву точку, дистанцію та розрахунковий час.
	Таблиця Users має в собі інформацію про користувачів програмної системи. Має такі поля: логін (потрібен для входу в акаунт), пароль, пошта та тип користувача (або клієнт, або адміністратор).
	Таблиця Drivers має в собі інформацію про водіїв. Має такі поля: ПІБ, дата народження, номер водійського посвідчення, термін придатності водійського посвідчення та номер телефону.
	Таблиця Vehicles має в собі інформцію про автомобілі корпорацій. Має такі поля: номер авто, тип авто, марка, модель, рік випуску авто, вага авто з заводу, поточна вага авто, місцезнаходження, об'єм паливного баку, поточний процент заповнення паливного баку та водія, що користується цим авто.
	Таблиця Transportations – таблиця, що має інформацію про кожне перевезення. Має такі поля: початок перевезення за часом, кінцевий час, опис вантажу, вага вантажу, певний шлях, певного водія та певне авто.


4	РЕАЛІЗАЦІЯ ПРОГРАМНОЇ СИСТЕМИ
4.1	Реалізація серверної частини


Для розробки серверну частину програмної системи використано платформу .NET 6.0 та мову програмування C#, а також технологію ASP.NET Core для розробки Web API.
Для зберігання даних використовується база даних SQL Server. Доступ до даних з серверної частини застосунку відбувається за допомогою технології Entity Framework Core.
Локалізація зроблена для двох мов – англійська та українська.
Серверна частина розроблена за архітектурним стилем REST. Специфікація усіх кінцевих точок REST API наведена у таблиці 1.1

Таблиця 1.1 – Специфікація REST
Метод	Посилання	Опис
GET	https://localhost:7001/api/Users/{id}
	Отримання інформації про користувача по id
POST	https://localhost:7001/api/Users/register
	Реєстрація нового користувача
POST	https://localhost:7001/api/Users/login
	Перевірка правильності даних для входу від користувача
GET	https://localhost:7001/api/Drivers
	Отримання списку всіх водіїв
GET	https://localhost:7001/api/ Drivers /{id}
	Отримання інформації про водія за id
POST	https://localhost:7001/api/ Drivers
	Додавання нового водія

Продовження таблиці 1.1 – Специфікація REST
Метод	Посилання	Опис
PUT	https://localhost:7001/api/ Drivers /{id}
	Оновлення інформації про водія
DELETE	https://localhost:7001/api/ Drivers /{id}
	Видалення водія за його id
GET	https://localhost:7001/api/ Vehicles
	Отримання інформації по всіх авто
GET	https://localhost:7001/api/ Vehicles/{id}
	Отримання інформації про авто за id
POST	https://localhost:7001/api/ Vehicles
	Додавання нового авто
PUT	https://localhost:7001/api/ Vehicles/{id}
	Оновлення інформації про авто
DELETE	https://localhost:7001/api/ Vehicles /{id}
	Видалення авто за id
GET	https://localhost:7001/api/Routes
	Отримання всіх маршрутів
GET	https://localhost:7001/api/ Routes /{id}
	Отримання певного маршруту за його id 
POST	https://localhost:7001/api/ Routes 	Додавання нового маршруту
PUT	https://localhost:7001/api/ Routes/{id}
	Оновлення інформації про маршрут
DELETE	https://localhost:7001/api/ Routes/{id}
	Видалення маршруту за id
GET	https://localhost:7001/api/Transportations
	Отримання інформації про всі перевезення 


Продовження таблиці 1.1 – Специфікація REST
Метод	Посилання	Опис
GET	https://localhost:7001/api/ Transportations /{id}

	Отримання інформації про певне перевезення за його id
POST	https://localhost:7001/api/ Transportations	Додавання нового перевезення
PUT	https://localhost:7001/api/ Transportations/{id}
	Оновлення інформації про перевезення
DELETE	https://localhost:7001/api/ Transportations/{id}
	Видалення перевезення за id


ВИСНОВКИ


Під час роботи над курсовим проектом був ознайомлений процес проектування та створення програмних систем, які складаються з різних взаємопов'язаних компонентів та використовують різні технології. Було взято за приклад створення програмної системи для відстеження транспортних засобів підприємств.
Спочатку було ретельно проаналізовано область предмету, визначено основні категорії користувачів системи (клієнти, водії та адміністратори) та їхні потреби. Результати аналізу було детально описано у вигляді функціональних вимог, які було реалізувати у системі. Потім було розроблено та реалізовано інформаційну систему, яка складалася з серверної частини з базою даних, клієнтської браузерної частини, розумних пристроїв та мобільного додатка.
Усі частини системи були розроблені згідно з принципами чистої масштабованої архітектури. Було використано відповідні архітектурні стилі та патерни для кожної частини системи. Крім того, було дотримано принципів DRY (не повторюйте себе), KISS (будьте простими), SOLID та інших.
Для реалізації системи було використано різноманітні технології. Серверна частина була реалізована з використанням ASP.NET Core та платформи .NET 6, з використанням СУБД MS SQL Server. Клієнтська частина була створена з використанням Java Script, HTML та CSS. Програмне забезпечення для розумних пристроїв було написане на мові програмування C++ з використанням допоміжних бібліотек для програмування контролера ESP-32. Мобільний додаток був розроблений за допомогою мови програмування Java.
Результатом роботи стала система, яка відповідає всім вимогам та потребам потенційних користувачів і може бути використана для відстеження транспортних засобів.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	.NET Documentation. URL: https://learn.microsoft.com/en-us/dotnet/
2.	Гамма, Е., Хелм, Р., Джонсон, Р., & Вліссідес, Д. (1995). Патерни проєктування. Прийоми ООП. USA.
3.	https://uk.wikipedia.org/wiki/Design_Patterns_(%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0)
4.	https://uk.wikipedia.org/wiki
5.	Посилання на GitHub з кодом: https://github.com/NureRozovArtem/apzkr-pzpi-21-6-rozov-artem
6.	Посилання на відео: https://youtu.be/SccNruXR7Sk


ДОДАТОК А
Фрагменти коду серверної частини


UsersController.cs 

 
namespace VehiclesTrackingSystem.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class UsersController : Controller
    {
        private readonly MyDbContext _context;
        private readonly IStringLocalizer<LoginView> _localizer;

        public UsersController(MyDbContext context, IStringLocalizer<LoginView> localizer)
        {
            _context = context;
            _localizer = localizer;
        }

        [HttpGet("login")]
        public IActionResult LoginView()
        {
            Console.WriteLine("loginTitle = " + _localizer["loginTitle"]);
            ViewData["loginTitle"] = _localizer["loginTitle"];
            ViewData["usernamePlaceholder"] = _localizer["usernamePlaceholder"];
            ViewData["passwordPlaceholder"] = _localizer["passwordPlaceholder"];
            ViewData["loginButton"] = _localizer["loginButton"];
            ViewData["registerLinkText"] = _localizer["registerLinkText"];
            ViewData["registerLink"] = _localizer["registerLink"];
            return View("Index");
        }

        [HttpPost("login")]
        public async Task<IActionResult> Login(LoginModel loginModel)
        {
            var user = await _context.Users.FirstOrDefaultAsync(u => u.Login == loginModel.Login && u.Password == loginModel.Password);
            if (user == null)
            {
                return BadRequest(new { message = "Користувач не знайден або неправильні дані." });
            }

            HttpContext.Session.SetInt32("UserId", user.UserId);

            return Ok(new { userId = user.UserId });
        }

        [HttpGet("register")]
        public IActionResult RegisterView()
        {
            return View("Registration");
        }

        [HttpPost("register")]
        public async Task<IActionResult> Register([FromBody] RegistrationModel registerModel)
        {
            try
            {
                if (await _context.Users.AnyAsync(u => u.Login == registerModel.Login))
                {
                    return Conflict("User with this login already exists.");
                }

                var newUser = new User
                {
                    Login = registerModel.Login,
                    Password = registerModel.Password,
                    Email = registerModel.Email,
                    UserType = registerModel.UserType
                };

                _context.Users.Add(newUser);
                await _context.SaveChangesAsync();

                return Ok("Registration successful!");
            }
            catch (Exception ex)
            {
                return StatusCode(500, "An error occurred while processing your request.");
            }
        }

        [HttpGet("{id}")]
        public async Task<IActionResult> GetUserById(int id)
        {
            var user = await _context.Users.FindAsync(id);
            if (user == null)
            {
                return NotFound("Користувача не знайдено.");
            }

            return Ok(user);
        }
    }
} 


ДОДАТОК Б
Фрагменти коду клієнтської частини

	Файл index.cshtml (Представлення для входу в акаунт)

 
<!DOCTYPE html>
<html lang="@Thread.CurrentThread.CurrentCulture.Name">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@ViewData["loginTitle"]</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        .login-container {
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            width: 300px;
        }

        .login-container h2 {
            margin-bottom: 20px;
            text-align: center;
        }

        .login-container input[type="text"],
        .login-container input[type="password"],
        .login-container input[type="submit"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
        }

        .login-container input[type="submit"] {
            background-color: #007bff;
            color: #fff;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .login-container input[type="submit"]:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <div class="login-container">
        <h2>@ViewData["loginTitle"]</h2>
        <form id="loginForm">
            <input type="text" name="username" placeholder="@ViewData["usernamePlaceholder"]" required><br>
            <input type="password" name="password" placeholder="@ViewData["passwordPlaceholder"]" required><br>
            <input type="submit" value="@ViewData["loginButton"]">
        </form>
        <p>@ViewData["registerLinkText"] <a href="/api/users/register">@ViewData["registerLink"]</a></p>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            document.getElementById('loginForm').addEventListener('submit', function (event) {
                event.preventDefault();

                var formData = {
                    Login: this.elements["username"].value,
                    Password: this.elements["password"].value
                };

                fetch('/api/users/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.userId) {
                        window.location.href = '/Transportations/Page/user/' + data.userId;
                    } else {
                        alert('Error: ' + data.message);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error occurred, please try again later.');
                });
            });
        });
    </script>
</body>
</html>
 
 
ДОДАТОК В
Фрагменти коду програмного забезпечення для розумних пристроїв

 
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <TinyGPS.h>

const char* ssid = "Wokwi-GUEST";
const char* password = "";
const char* serverUrl = "https://5ed9-178-165-27-143.ngrok-free.app/Vehicles/UpdateLocation/1";

const char* gpsData = "$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47";

TinyGPS gps;

void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  Serial.println("Connected to WiFi");
  randomSeed(analogRead(0));
}

void loop() {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin(serverUrl, true);
    
    http.addHeader("Content-Type", "application/json");

    DynamicJsonDocument doc(256);
    doc["newLocation"] = gpsData; 
    char buffer[256];
    serializeJson(doc, buffer);
    String jsonData = String(buffer);

    Serial.println("Sending PUT request to: " + String(serverUrl));
    Serial.println("Data: " + jsonData);

    int httpResponseCode = http.PUT(jsonData);

    if (httpResponseCode > 0) {
      Serial.print("HTTP Response code: ");
      Serial.println(httpResponseCode);
    } else {
      Serial.print("Error code: ");
      Serial.println(httpResponseCode);
    }

    http.end();
  } else {
    Serial.println("Error in WiFi connection");
  }

  delay(10000);
}
 
 
 ДОДАТОК Г
Фрагменти коду мобільного застосунку


public class MainActivity2 extends AppCompatActivity {

    private RecyclerView recyclerView;
    private TransportationAdapter adapter;
    private static final String TAG = "MainActivity";
    private int userId;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main2);

        userId = getIntent().getIntExtra("userId", -1);
        System.out.println("userId = " + userId);

        recyclerView = findViewById(R.id.recyclerViewTransportations);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));

        loadTransportations();
    }

    private void loadTransportations() {
        ApiService apiService = RetrofitClient.getInsecureClient().create(ApiService.class);
        Call<List<Transportation>> call = apiService.getTransportations(userId);

        call.enqueue(new Callback<List<Transportation>>() {
            @Override
            public void onResponse(@NonNull Call<List<Transportation>> call, @NonNull Response<List<Transportation>> response) {
                if (response.isSuccessful() && response.body() != null) {
                    List<Transportation> transportations = response.body();
                    adapter = new TransportationAdapter(MainActivity2.this, transportations);
                    recyclerView.setAdapter(adapter);
                } else {
                    Toast.makeText(MainActivity2.this, "Failed to load transportations", Toast.LENGTH_SHORT).show();
                    System.out.println("Failed to load transportations");
                }
            }

            @Override
            public void onFailure(@NonNull Call<List<Transportation>> call, @NonNull Throwable t) {
                Toast.makeText(MainActivity2.this, "An error occurred: " + t.getMessage(), Toast.LENGTH_SHORT).show();
                Log.e("API_ERROR", "Error: ", t);
                System.out.println("An error occurred: " + t.getMessage());
            }
        });
    }

    @Override
    protected void onStart() {
        super.onStart();
        Log.d(TAG, "onStart called");
        //Toast.makeText(this, "onStart called", Toast.LENGTH_SHORT).show();
    }

    @Override
    protected void onResume() {
        super.onResume();
        Log.d(TAG, "onResume called");
        //Toast.makeText(this, "onResume called", Toast.LENGTH_SHORT).show();
    }

    @Override
    protected void onPause() {
        super.onPause();
        Log.d(TAG, "onPause called");
        //Toast.makeText(this, "onPause called", Toast.LENGTH_SHORT).show();
    }

    @Override
    protected void onStop() {
        super.onStop();
        Log.d(TAG, "onStop called");
        //Toast.makeText(this, "onStop called", Toast.LENGTH_SHORT).show();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy called");
        //Toast.makeText(this, "onDestroy called", Toast.LENGTH_SHORT).show();
    }

    @Override
    protected void onRestart() {
        super.onRestart();
        Log.d(TAG, "onRestart called");
        //Toast.makeText(this, "onRestart called", Toast.LENGTH_SHORT).show();
    }

}


ДОДАТОК Д
Результат перевірки роботи на антиплагіат
